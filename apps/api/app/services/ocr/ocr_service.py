from __future__ import annotations
import json, logging
from dataclasses import dataclass
from pathlib import Path
from typing import Any
from ...core.config import settings
from ...utils.hashing import sha256_file, dhash_hex, hamming_distance_hex
from .types import OCRResult, OCRLine

log = logging.getLogger(__name__)

@dataclass
class Fixture:
    id: str
    sha256: str
    dhash: str
    payload: dict[str, Any]

class MockOCR:
    def __init__(self, fixture_dir: Path):
        self.fixture_dir = fixture_dir
        self.fixtures: list[Fixture] = []
        self._load()

    def _load(self) -> None:
        self.fixture_dir.mkdir(parents=True, exist_ok=True)
        for p in sorted(self.fixture_dir.glob("*.json")):
            try:
                data = json.loads(p.read_text(encoding="utf-8"))
                self.fixtures.append(Fixture(id=data.get("id", p.stem), sha256=data["sha256"], dhash=data["dhash"], payload=data))
            except Exception as e:
                log.warning("Failed to load fixture %s: %s", p, e)
        log.info("Loaded %d OCR fixtures from %s", len(self.fixtures), self.fixture_dir)

    def match(self, image_path: Path, max_dist: int) -> tuple[Fixture | None, int | None, str]:
        if not self.fixtures:
            log.debug("No fixtures loaded for matching")
            return None, None, "none"
        s = sha256_file(image_path)
        log.debug("Image SHA256: %s", s[:16] + "...")
        for f in self.fixtures:
            if f.sha256 == s:
                log.info("Exact SHA256 match: fixture=%s", f.id)
                return f, 0, "sha256"
        h = dhash_hex(image_path)
        log.debug("Image dHash: %s", h)
        best, best_dist = None, None
        for f in self.fixtures:
            if not f.dhash or f.dhash == "<auto-generated>":
                log.debug("Skipping fixture %s: dHash not set", f.id)
                continue
            try:
                d = hamming_distance_hex(h, f.dhash)
                log.debug("Fixture %s: dHash distance=%d", f.id, d)
                if best_dist is None or d < best_dist:
                    best, best_dist = f, d
            except Exception as e:
                log.warning("Failed to compute distance for fixture %s: %s", f.id, e)
                continue
        if best is not None and best_dist is not None and best_dist <= max_dist:
            log.info("dHash match: fixture=%s, distance=%d, threshold=%d", best.id, best_dist, max_dist)
            return best, best_dist, "dhash"
        if best_dist is not None:
            log.warning("No fixture match: closest=%s, distance=%d, threshold=%d", best.id if best else "none", best_dist, max_dist)
        else:
            log.warning("No fixture match: no valid fixtures to compare")
        return None, None, "none"

    def run(self, image_path: Path) -> OCRResult | None:
        fix, dist, match_type = self.match(image_path, settings.OCR_DHASH_MAX_DISTANCE)
        if fix is None:
            log.debug("No fixture match found for %s", image_path.name)
            return None
        warnings: list[str] = []
        if match_type == "dhash" and dist is not None and dist > 0:
            warnings.append(f"FIXTURE_MATCH_APPROX:dhash_dist={dist}")
            log.info("Using approximate match: fixture=%s, distance=%d", fix.id, dist)
        else:
            log.info("Using exact match: fixture=%s", fix.id)
        raw = fix.payload.get("ocrTextRaw") or fix.payload.get("ocr_text_raw") or ""
        lines_payload = fix.payload.get("lines", [])
        lines: list[OCRLine] = []
        for ln in lines_payload:
            try:
                lines.append(OCRLine(text=ln.get("text", ""), confidence=float(ln.get("confidence", 0.9)), bbox=ln.get("bbox")))
            except Exception:
                continue
        parsed = fix.payload.get("parsed_receipt") or fix.payload.get("parsedReceipt")
        if parsed:
            log.debug("Using pre-parsed receipt from fixture: %d items", len(parsed.get("items", [])))
        return OCRResult(mode="mock", raw_text=raw, lines=lines, fixture_id=fix.id, parsed_receipt=parsed, warnings=warnings)

class PaddleEngine:
    def __init__(self) -> None:
        self._ocr = None

    def _init(self) -> None:
        if self._ocr is not None:
            return
        try:
            from paddleocr import PaddleOCR  # type: ignore
        except Exception as e:
            raise RuntimeError("PaddleOCR not installed. pip install paddleocr paddlepaddle") from e
        self._ocr = PaddleOCR(use_angle_cls=settings.PADDLE_OCR_USE_ANGLE_CLS, lang=settings.PADDLE_OCR_LANG, show_log=False, cpu_threads=settings.PADDLE_OCR_CPU_THREADS)

    def run(self, image_path: Path) -> OCRResult:
        self._init()
        assert self._ocr is not None
        result = self._ocr.ocr(str(image_path), cls=settings.PADDLE_OCR_USE_ANGLE_CLS)
        lines: list[OCRLine] = []
        raw_lines: list[str] = []
        for page in result or []:
            for det in page or []:
                try:
                    bbox = det[0]
                    text, conf = det[1]
                    t = str(text)
                    c = float(conf)
                    lines.append(OCRLine(text=t, confidence=c, bbox=bbox))
                    raw_lines.append(t)
                except Exception:
                    continue
        return OCRResult(mode="paddle", raw_text="\n".join(raw_lines), lines=lines, warnings=[])

class OCRService:
    def __init__(self, fixture_dir: Path):
        self.mock = MockOCR(fixture_dir)
        self.paddle = PaddleEngine()

    def run(self, image_path: Path) -> OCRResult:
        mode = settings.OCR_MODE.lower().strip()
        if mode in ("mock", "auto"):
            r = self.mock.run(image_path)
            if r is not None:
                return r
            if mode == "mock":
                return OCRResult(mode="mock", raw_text="", lines=[], warnings=["NO_FIXTURE_MATCH"])
        if mode in ("paddle", "auto"):
            try:
                return self.paddle.run(image_path)
            except Exception as e:
                log.exception("PaddleOCR failed: %s", e)
                return OCRResult(mode=mode, raw_text="", lines=[], warnings=["OCR_FAILED"])
        return OCRResult(mode=mode, raw_text="", lines=[], warnings=["OCR_MODE_UNKNOWN"])
